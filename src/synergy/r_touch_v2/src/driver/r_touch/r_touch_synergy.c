/***********************************************************************************************************************
* DISCLAIMER
* This software is supplied by Renesas Electronics Corporation and is only intended for use with Renesas products. No
* other uses are authorized. This software is owned by Renesas Electronics Corporation and is protected under all
* applicable laws, including copyright laws.
* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
* THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED. TO THE MAXIMUM
* EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES
* SHALL BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR ANY REASON RELATED TO THIS
* SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
* Renesas reserves the right, without notice, to make changes to this software and to discontinue the availability of
* this software. By using this software, you agree to the additional terms and conditions found by accessing the
* following link:
* http://www.renesas.com/disclaimer
*
* Copyright (C) 2016 Renesas Electronics Corporation. All rights reserved.
***********************************************************************************************************************/


/***********************************************************************************************************************
* File Name : r_touch_synergy.c
* Version : 2.0: [2016-08-02::4-30-05] Version 2.0 Complete.
* Description : This module implements middle-ware to be used with data generated by the CTSU and allows the user to
* estimate if a sensor is being touched.
***********************************************************************************************************************/
/*******************************************************************************************************************//**
 * @file
 ***********************************************************************************************************************/
/*******************************************************************************************************************//**
 * @defgroup R_TOUCH Function Definitions
 * @brief Functions which allow estimation of user input through capacitive touch sensors.
 * @{
 * Functions defined in this module are declared in the interface.
 ***********************************************************************************************************************/
#include <stdlib.h>
#include <string.h>

#include "r_touch.h"
#include "r_touch_private.h"

#define ASSERT(test)    if(false == (test)){return TOUCH_ERR_INVALID_PARAM;}

/**
 * Fixed 32-bit flag used to identify an open control block
 */
#define OPEN            (0x4F50454e)
/**
 * Upper limit value to use when performing initial offset adjustment
 */
#define TUNING_UPPER_LIMIT                      (TOUCH_CFG_TUNING_UPPER_DRIFT_LIMIT)
/**
 * Lower limit value to use when performing initial offset adjustment
 */
#define TUNING_LOWER_LIMIT                      (TOUCH_CFG_TUNING_LOWER_DRIFT_LIMIT)
/**
 * Maximum number of errors allowed before reporting it to upper layers.
 */
#define MAX_ERROR_COUNT                         (TOUCH_CFG_MAX_ERROR_COUNT)

#define USEC_PER_SENSOR                         (520U)


/***********************************************************************************************************************
 Private Functions
 **********************************************************************************************************************/
static bool is_touched(void * p_arg);
static void sensor_drift_adjust(void * p_arg);
static void filter_2n_lpraf(void* p_arg);
static void sensor_optimize_sensitivity(void * p_arg);
static void touch_common_callback(ctsu_callback_arg_t const*const p_arg);
static bool already_open(touch_instance_ctrl_t const*const p_ctrl_1, touch_instance_ctrl_t const*const p_ctrl_2);
static touch_err_t read_sensor_parameter(touch_instance_ctrl_t * const p_ctrl, touch_read_t const * const p_arg);
static touch_err_t write_sensor_parameter(touch_instance_ctrl_t * const p_ctrl, touch_control_arg_t const *const p_arg);
static uint16_t get_sensor_offset(touch_instance_ctrl_t * const p_ctrl, uint8_t rx_ch, uint8_t tx_ch);

static ctsu_err_t filter(touch_instance_ctrl_t * const p_ctrl);
static uint16_t sensors_touched(touch_instance_ctrl_t * const p_ctrl);
static void drift_compensation(touch_instance_ctrl_t * const p_ctrl);
static ctsu_err_t sensitivity_optimization(touch_instance_ctrl_t * const p_ctrl);

/**
 * Local control blocks used by the driver.
 */
static touch_instance_ctrl_t * touch_ctrl_blk[TOUCH_CFG_MAX_OPEN_TOUCH_CONFIGS];
static size_t touch_ctrl_blk_count;
/***********************************************************************************************************************
 Functions
 **********************************************************************************************************************/

static const ssp_version_t touch_version =
{
    .api_version_major  = TOUCH_API_VERSION_MAJOR,
    .api_version_minor  = TOUCH_API_VERSION_MINOR,
    .code_version_major = TOUCH_CODE_VERSION_MAJOR,
    .code_version_minor = TOUCH_CODE_VERSION_MINOR,
};

touch_api_t const g_touch_on_touch =
{
 .open          = R_TOUCH_Open,
 .close         = R_TOUCH_Close,
 .scan          = R_TOUCH_StartScan,
 .update        = R_TOUCH_Update,
 .read          = R_TOUCH_Read,
 .calibrate     = R_TOUCH_Calibrate,
 .control       = R_TOUCH_Control,
 .versionGet    = R_TOUCH_GetVersion,
};

/***********************************************************************************************************************
* Function Name: R_TOUCH_GetVersion
* Description  : Returns the version number of the module as a 32-bit integer.
* Arguments    : none
* Return Value : Returns the version number of the module as a 32-bit integer.
***********************************************************************************************************************/
ssp_err_t R_TOUCH_GetVersion(ssp_version_t * const p_version)
{
#if TOUCH_CFG_PARAM_CHECKING_ENABLE
    SSP_ASSERT(NULL != p_version);
#endif
    p_version->version_id =  touch_version.version_id;
    return SSP_SUCCESS;
}
/***********************************************************************************************************************
End of function R_TOUCH_GetVersion
***********************************************************************************************************************/

/***********************************************************************************************************************
* Function Name: R_TOUCH_Open
* Description  : Saves the configuration information into an empty control block.
*                   Enables lower level CTSU hardware module.
*                   Initializes necessary data in the handles.
* Arguments    :    p_id -
*                       Pointer to a user specified location where the control block
*                       index will be stored. The user should use this control block number to
*                       perform all future associated actions.
*                   p_cfg -
*                       Pointer to a Touch configuration data and structures
*                       (created by Workbench6).
* Return Value : TOUCH_SUCCESS, TOUCH_ERR_INSUFFICIENT_MEMORY, TOUCH_ERR_INVALID_PARAM
***********************************************************************************************************************/
touch_err_t R_TOUCH_Open(touch_ctrl_t * const p_ctrl, touch_cfg_t const * const p_cfg)
{
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
    ASSERT(p_cfg!=NULL);
    ASSERT(p_cfg->p_ctsu!=NULL);
    ASSERT(p_cfg->buffer.p_start != NULL);
    ASSERT(p_cfg->p_binary_result != NULL);
    ASSERT(p_cfg->p_common != NULL);
    ASSERT(p_cfg->p_sensor != NULL);
#endif
    touch_instance_ctrl_t * pctrl = p_ctrl;
    uint8_t * ch_en;

    typedef union
    {
        ctsu_cfg_t ctsu_cfg_copy;
        ctsu_control_arg_t ctsu_control_arg;
    }u_ctsu_t;

    u_ctsu_t ctsu;
    memcpy(&ctsu.ctsu_cfg_copy, p_cfg->p_ctsu->p_cfg, sizeof(ctsu_cfg_t) );
    ctsu.ctsu_cfg_copy.p_callback = touch_common_callback;

    ctsu_instance_t const * const p_ctsu = p_cfg->p_ctsu;

    sensor_info_t * const p_sensor_info = (sensor_info_t *)p_cfg->buffer.p_start;

    touch_instance_ctrl_t ctrl_blk_local =
    {
        .open = OPEN,
        .lock = {0},
        .p_ctsu = p_cfg->p_ctsu,
        .mode = CTSU_MODE_NOT_SUPPORTED,
        .scan_errors = 0,
        .num_rx = 0,
        .num_tx = 0,
        .num_sensors = 0,
        .drift_hold_limit = p_cfg->p_common->drift_hold_limit,
        .on_limit = p_cfg->p_common->on_limit,
        .max_touched_sensors = p_cfg->p_common->max_touched_sensors,
        .p_sensor = p_sensor_info,
        .num_ignored = p_cfg->num_ignored,
        .p_ignored = p_cfg->p_ignored,
        .p_filter = ((NULL!=p_cfg->custom.p_filter) ?
                (p_cfg->custom.p_filter):(filter_2n_lpraf)),
        .num_touched = 0,
#if (TOUCH_CFG_MULTITOUCH_REJECTION_TYPE > 0)
        .multi_touch = false,
#endif
        .callback_count = (offsetof(touch_instance_ctrl_t,callback_count) - offsetof(touch_instance_ctrl_t, p_callback))/(sizeof(ctrl_blk_local.p_callback[0])),
        .p_touch_detect = ((NULL!=p_cfg->custom.p_touch_detect) ?
                (p_cfg->custom.p_touch_detect) : (is_touched)),
        .p_binary_result = p_cfg->p_binary_result,
    };

    /* Open Lower level control block */
    ctsu_err_t ctsu_err = p_ctsu->p_api->open(p_ctsu->p_ctrl, &ctsu.ctsu_cfg_copy);

    /* Get Sensor electrode type (rx/tx) masks */
    ctsu.ctsu_control_arg.cmd = CTSU_CMD_GET_SENSOR_COUNT;
    ctsu.ctsu_control_arg.p_context = (void*)&ctrl_blk_local.num_sensors;

    ctsu_err |= p_ctsu->p_api->control(p_ctsu->p_ctrl, &ctsu.ctsu_control_arg);
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
    if(CTSU_SUCCESS!=ctsu_err)
    {
        return (touch_err_t)ctsu_err;
    }
#endif

    ctsu.ctsu_control_arg.cmd = CTSU_CMD_GET_MODE;
    ctsu.ctsu_control_arg.p_context = &ctrl_blk_local.mode;
    ctsu_err |= p_ctsu->p_api->control(p_ctsu->p_ctrl, &ctsu.ctsu_control_arg);
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
    if(CTSU_SUCCESS!=ctsu_err)
    {
        return (touch_err_t)ctsu_err;
    }
#endif

    uint64_t ctsuchrx = 0;
    ctsu.ctsu_control_arg.cmd = CTSU_CMD_GET_CTSUCHAC;
    ctsu.ctsu_control_arg.p_context = &ctsuchrx;
    ctsu_err = p_ctsu->p_api->control(p_ctsu->p_ctrl, &ctsu.ctsu_control_arg);
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
    if(CTSU_SUCCESS!=ctsu_err)
    {
        return (touch_err_t)ctsu_err;
    }
#endif

    uint64_t ctsuchtx = 0;
    ctsu.ctsu_control_arg.cmd = CTSU_CMD_GET_CTSUCHTRC;
    ctsu.ctsu_control_arg.p_context = &ctsuchtx;
    ctsu_err = p_ctsu->p_api->control(p_ctsu->p_ctrl, &ctsu.ctsu_control_arg);
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
    if(CTSU_SUCCESS!=ctsu_err)
    {
        return (touch_err_t)ctsu_err;
    }
#endif
    ctsuchrx = ctsuchrx ^ ctsuchtx;

    ch_en = (uint8_t *) ctrl_blk_local.offset_en;

    /* Calculate offsets of rx and tx */
    {
        uint8_t * num_tx = (uint8_t*)&ctrl_blk_local.num_tx;
        uint8_t * num_rx = (uint8_t*)&ctrl_blk_local.num_rx;
        for (uint8_t itr = 0; itr < (LAST_TS + 1); itr++)
        {
            /* Iterate through to the last sensor */
            ch_en[itr] = 0xFF;
            if(ctsuchtx & ((uint64_t)1<<itr))
            {
                /* CTSU will be operated in mutual mode. */
                ch_en[itr] = *num_tx;
                *num_tx = ((*num_tx) + 1U) & 0xFF;
            }
            if(ctsuchrx & ((uint64_t)1<<itr))
            {
                /* CTSU will be operated in self mode. */
                ch_en[itr] = *num_rx;
                *num_rx = ((*num_rx) + 1U) & 0xFF;
            }
        }
    }

    {
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
        ASSERT(ctrl_blk_local.num_sensors == ((CTSU_MODE_MUTUAL_CAPACITANCE==ctrl_blk_local.mode)?
                ctrl_blk_local.num_tx*ctrl_blk_local.num_rx: ctrl_blk_local.num_rx));
#endif
        if(p_cfg->buffer.size < (ctrl_blk_local.num_sensors * sizeof(sensor_info_t)))
        {
            p_ctsu->p_api->close(p_ctsu->p_ctrl);

            /* Insufficient memory to maintain all sensors. */
            return TOUCH_ERR_INSUFFICIENT_MEMORY;
        }
    }

    if(CTSU_SUCCESS==ctsu_err)
    {
        if(true==already_open(&ctrl_blk_local, pctrl))
        {
            /* Block already open */
            uint8_t callback_index = 0;
            for(uint8_t itr = 0 ; itr < (uint8_t)(pctrl->callback_count); itr++)
            {
                if (NULL == pctrl->p_callback[itr])
                {
                    /* Open spot to put a callback */
                    callback_index = itr;
                }
                else if (pctrl->p_callback[itr] == p_cfg->p_callback)
                {
                    callback_index = itr;
                    break;
                }
                else
                {
                    /* GSCE CODAN Error Elimination: Do Nothing */
                }
            }
            pctrl->p_callback[callback_index] = p_cfg->p_callback;
            pctrl->upper_level_count = (pctrl->upper_level_count + 1U) & UINT16_MAX;
            return TOUCH_SUCCESS;
        }
        else
        {

            /* Get the first unused control block and write to it. */
            uint32_t touch_hdl = 0;
            for(touch_hdl = 0; touch_hdl < TOUCH_CFG_MAX_OPEN_TOUCH_CONFIGS; touch_hdl++)
            {
                if (NULL == touch_ctrl_blk[touch_hdl])
                {
                    touch_ctrl_blk[touch_hdl] = p_ctrl;
                    break;
                }
            }
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
            ASSERT(touch_hdl < TOUCH_CFG_MAX_OPEN_TOUCH_CONFIGS);
#endif
            touch_ctrl_blk_count++;
            memset(ctrl_blk_local.p_callback, 0, TOUCH_CFG_MAX_UPPER_LAYER_CALLBACKS* sizeof(touch_callback_t));
            ctrl_blk_local.p_callback[TOUCH_CFG_MAX_UPPER_LAYER_CALLBACKS-1] = p_cfg->p_callback;


        }
    }


    memset(p_sensor_info, 0, (ctrl_blk_local.num_sensors * sizeof(sensor_info_t)));
    for(uint16_t itr = 0; itr < ctrl_blk_local.num_sensors; itr++)
    {
        p_sensor_info[itr].operation.bit.filter = 1;
        p_sensor_info[itr].operation.bit.detection = 1;
        p_sensor_info[itr].operation.bit.drift_comp = 1;
        p_sensor_info[itr].operation.bit.sensor_optimize = 1;

        p_sensor_info[itr].p_touch_sensor = &p_cfg->p_sensor[itr];
        p_sensor_info[itr].max_input = 0;
        p_sensor_info[itr].min_input = UINT16_MAX;
#if (TOUCH_CFG_VARIABLE_DRIFT_RATES==1)
        p_sensor_info[itr].drift_interval = p_cfg->p_sensor[itr].drift_rate;
#endif
        p_sensor_info[itr].p_filter_state = ((NULL!=p_cfg->custom.p_filter) ?
                (p_cfg->custom.p_filter_instance[itr]):(void*)NULL);
    }

    /* Channel ignore mechanism */
    for(uint8_t itr = 0; itr < p_cfg->num_ignored; itr++)
    {
        uint16_t offset;
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
        ASSERT(ctrl_blk_local.num_rx > ch_en[p_cfg->p_ignored[itr].rx]);
#endif
        if(CTSU_MODE_MUTUAL_CAPACITANCE==ctrl_blk_local.mode)
        {
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
            ASSERT(ctrl_blk_local.num_tx > ch_en[p_cfg->p_ignored[itr].tx]);
#endif
            offset = (uint16_t)((ch_en[p_cfg->p_ignored[itr].rx]*ctrl_blk_local.num_tx)+ch_en[p_cfg->p_ignored[itr].tx]);
        }
        else
        {
            offset = ch_en[p_cfg->p_ignored[itr].rx];
        }

        if(offset < ctrl_blk_local.num_sensors)
        {
            /* Turn off all phases */
            p_sensor_info[offset].operation.bit.filter = 0;
            p_sensor_info[offset].operation.bit.detection = 0;
            p_sensor_info[offset].operation.bit.drift_comp = 0;
            p_sensor_info[offset].operation.bit.sensor_optimize = 0;
        }
    }

    memcpy(pctrl, &ctrl_blk_local, sizeof(touch_instance_ctrl_t));
    pctrl->upper_level_count = 1;

    (void)ctsu_err;     //Gets rid of compiler warnings

    return TOUCH_SUCCESS;
}
/***********************************************************************************************************************
End of function R_TOUCH_Open
***********************************************************************************************************************/

/***********************************************************************************************************************
* Function Name: R_TOUCH_Close
* Description  : Close the specified control block.
* Arguments    : id -
*                   Control Block Identifier returned by a successful call to R_TOUCH_Open
* Return Value : TOUCH_SUCCESS, TOUCH_ERR_LOCKED
***********************************************************************************************************************/
touch_err_t R_TOUCH_Close(touch_ctrl_t * const p_ctrl)
{
    ctsu_err_t ctsu_err;
    touch_instance_ctrl_t * pctrl = p_ctrl;
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
    ASSERT(OPEN == pctrl->open);
#endif
    /** a. Check resource lock */
    if( SSP_SUCCESS !=R_BSP_SoftwareLock(&pctrl->lock) )
    {
        /* Other API is busy with this handle. */
        return TOUCH_ERR_LOCKED;
    }

    /** b. Close lower level  */
    ctsu_err = pctrl->p_ctsu->p_api->close(pctrl->p_ctsu->p_ctrl);
    if( CTSU_SUCCESS != ctsu_err)
    {
        /* Unlock the handle, return the error. */
        R_BSP_SoftwareUnlock(&pctrl->lock);
        return (touch_err_t)ctsu_err;
    }

    /** c. Release memory resource. */
    if(0 == (--pctrl->upper_level_count))
    {
        /* No more upper levels using the control block. */
        uint32_t touch_hdl = 0;
        for(touch_hdl = 0; touch_hdl < TOUCH_CFG_MAX_OPEN_TOUCH_CONFIGS; touch_hdl++)
        {
            if(touch_ctrl_blk[touch_hdl]==p_ctrl)
            {
                touch_ctrl_blk[touch_hdl] = NULL;
                break;
            }
        }

#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
        ASSERT(touch_hdl < TOUCH_CFG_MAX_OPEN_TOUCH_CONFIGS);
#endif
        touch_ctrl_blk_count--;
        memset(pctrl, 0, sizeof(touch_instance_ctrl_t));
    }

    R_BSP_SoftwareUnlock(&pctrl->lock);

    return TOUCH_SUCCESS;
}
/***********************************************************************************************************************
End of function R_TOUCH_Close
***********************************************************************************************************************/

/***********************************************************************************************************************
* Function Name: R_TOUCH_StartScan
* Description  : Perform a scan with the provided control block.
* Arguments    : id -
*                   Control Block Identifier returned by a successful call to R_TOUCH_Open
* Return Value : TOUCH_SUCCESS, TOUCH_ERR_LOCKED, TOUCH_ERR_CTSU_LOCKED
***********************************************************************************************************************/
touch_err_t R_TOUCH_StartScan(touch_ctrl_t * const p_ctrl)
{
    ctsu_err_t ctsu_err;

    touch_callback_arg_t cb_args;
    touch_instance_ctrl_t * pctrl = p_ctrl;
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
    ASSERT(OPEN == pctrl->open);
#endif
    /** a. Check resource lock */
    if( SSP_SUCCESS !=R_BSP_SoftwareLock(&pctrl->lock) )
    {
        /* Other API is busy with this handle. */
        return TOUCH_ERR_LOCKED;
    }

    /** b. Start scan with lower level driver. */
    ctsu_err = pctrl->p_ctsu->p_api->scan(pctrl->p_ctsu->p_ctrl);

    if(CTSU_SUCCESS!=ctsu_err)
    {
        R_BSP_SoftwareUnlock(&pctrl->lock);
        return TOUCH_ERR_CTSU_LOCKED;
    }

    cb_args.event = TOUCH_EVENT_SCAN_STARTED;
    cb_args.handle_num = p_ctrl;
    cb_args.info = (pctrl->num_sensors * ((CTSU_MODE_MUTUAL_CAPACITANCE == pctrl->mode) ? 2U : 1U)) * USEC_PER_SENSOR;

    /** f. Upper layer callback */
    for(uint16_t itr = 0; itr < TOUCH_CFG_MAX_UPPER_LAYER_CALLBACKS; itr++)
    {
        if (NULL != pctrl->p_callback[itr])
        {
            pctrl->p_callback[itr](&cb_args);
        }
    }

    return TOUCH_SUCCESS;
}
/***********************************************************************************************************************
End of function R_TOUCH_StartScan
***********************************************************************************************************************/

/***********************************************************************************************************************
* Function Name: R_TOUCH_Update
* Description  : Update Touch Sensing information after a control block has been
*                   successfully scanned.
* Arguments    : id Control Block Identifier returned by a successful call to R_TOUCH_Open
* Return Value : TOUCH_SUCCESS, TOUCH_ERR_LOCKED,
***********************************************************************************************************************/
touch_err_t R_TOUCH_Update(touch_ctrl_t * const p_ctrl)
{
    touch_callback_arg_t cb_args;
    uint16_t touched_sensor_count = 0;
    ctsu_err_t ctsu_err;
    touch_instance_ctrl_t * pctrl = p_ctrl;
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
    ASSERT(OPEN == pctrl->open);
#endif
    cb_args.event = TOUCH_EVENT_PARAMETERS_UPDATED;
    cb_args.handle_num = p_ctrl;

    if( SSP_SUCCESS !=R_BSP_SoftwareLock(&pctrl->lock) )
    {
        return TOUCH_ERR_LOCKED;
    }

    ctsu_err = filter(pctrl);

    if(CTSU_SUCCESS != ctsu_err)
    {
        R_BSP_SoftwareUnlock(&pctrl->lock);
        return TOUCH_ERR_INVALID_PARAM;
    }

    touched_sensor_count = sensors_touched(pctrl);

    /* Reset the drift hold count and on counter if number of sensors touched has changed*/
    if(touched_sensor_count != pctrl->num_touched)
    {
        pctrl->drift_hold_count = pctrl->drift_hold_limit;
        pctrl->on_count = 0;
    }

    if (0 == touched_sensor_count)
    {
        /* Sensors not touched anymore */
        pctrl->drift_hold_count = 0;
        pctrl->on_count = 0;
    }

    pctrl->num_touched = touched_sensor_count;

    cb_args.info = touched_sensor_count;

    R_BSP_SoftwareUnlock(&pctrl->lock);

    /** f. Upper layer callback */
    for(uint16_t itr = 0; itr < TOUCH_CFG_MAX_UPPER_LAYER_CALLBACKS; itr++)
    {
        if (NULL != pctrl->p_callback[itr])
        {
            pctrl->p_callback[itr](&cb_args);
        }
    }

    if( SSP_SUCCESS !=R_BSP_SoftwareLock(&pctrl->lock) )
    {
        return TOUCH_ERR_LOCKED;
    }

    drift_compensation(pctrl);

    pctrl->drift_hold_count = (uint16_t)(pctrl->drift_hold_count - (((pctrl->drift_hold_count > 0)
            &&(touched_sensor_count > 0)) ?
                    (1U):(0)));
    pctrl->on_count = (uint16_t)(pctrl->on_count + (((pctrl->on_count <= pctrl->on_limit)
            &&(touched_sensor_count > 0)) ?
                    (1U):(0)));

    sensitivity_optimization(pctrl);

    if(CTSU_SUCCESS != ctsu_err)
    {
        R_BSP_SoftwareUnlock(&pctrl->lock);
        return TOUCH_ERR_INVALID_PARAM;
    }

    R_BSP_SoftwareUnlock(&pctrl->lock);
    return TOUCH_SUCCESS;
}
/***********************************************************************************************************************
End of function R_TOUCH_Update
***********************************************************************************************************************/

/***********************************************************************************************************************
* Function Name: R_TOUCH_Read
* Description  : Read results updated with R_TOUCH_Update. This function will create copy of
*                   data into application space.
* Arguments    : id -
*                   Identifier returned by a successful call to R_TOUCH_Open
*                p_arg -
*                   Structure specifying information about what user wants to read.
 * Return Value : TOUCH_SUCCESS, TOUCH_ERR_INVALID_CMD, TOUCH_ERR_INSUFFICIENT_MEMORY, TOUCH_ERR_LOCKED,
 *                  TOUCH_ERR_INVALID_PARAM
***********************************************************************************************************************/
touch_err_t R_TOUCH_Read(touch_ctrl_t * const p_ctrl, touch_read_t const * const p_arg)
{
    uint32_t itr;
    touch_err_t touch_err = TOUCH_SUCCESS;

    touch_instance_ctrl_t * const pctrl = p_ctrl;
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
    ASSERT(OPEN == pctrl->open);
#endif

    /** a. Check resource lock (Removed as it causes lock-ups when data is requested asynchronously,
     * which is fine) */

    /** b. Read from control block into user specified destination. */
    if(TOUCH_DATA_BINARY==p_arg->read_cmd)
    {
        uint16_t sensor_offset;
        uint8_t result;
        uint8_t bit_mask;
        uint8_t bit_offset;
        uint8_t byte_offset;
        uint8_t * p_result = p_arg->p_dest;
        for(itr = 0; (itr < p_arg->sensor_count) && (p_arg->sensor_count > 0); itr++)
        {
            sensor_offset = get_sensor_offset(pctrl, p_arg->sensor[itr].rx, p_arg->sensor[itr].tx);
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
        ASSERT(pctrl->num_sensors > sensor_offset);
#endif
            byte_offset = (uint8_t)(sensor_offset>>3U);
            bit_offset  = sensor_offset & 7U;
            bit_mask = (uint8_t)(1U<<bit_offset);
            result = pctrl->p_binary_result[byte_offset];
            if((bit_mask & result)==bit_mask)
            {
                byte_offset = (uint8_t)(itr>>3);
                bit_offset  = itr & 7U;
                bit_mask = (uint8_t)(1<<bit_offset);
                p_result[byte_offset] |= bit_mask;
            }
            else
            {
                byte_offset = (uint8_t)(itr>>3U);
                bit_offset  = itr & 7U;
                bit_mask = (uint8_t)(1U<<bit_offset);
                p_result[byte_offset] = (uint8_t)(p_result[byte_offset] & (~bit_mask));
            }
        }
        for (itr = 0; (itr < pctrl->num_sensors) && (0 == p_arg->sensor_count); itr += 8)
        {
            byte_offset = (uint8_t)(itr>>3U);
            result = pctrl->p_binary_result[byte_offset];
            p_result[byte_offset] |= result;
        }
    }
    else
    {
        switch(p_arg->read_cmd)
        {
            case TOUCH_DATA_CTSU_HW_IDENTIFIER:
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
                ASSERT(p_arg->size >= sizeof(pctrl->p_ctsu));
#endif
                memcpy(p_arg->p_dest, &pctrl->p_ctsu, sizeof(pctrl->p_ctsu));
                break;
            case TOUCH_DATA_OPERATION_FLAGS:
                touch_err = read_sensor_parameter(pctrl, p_arg);
                break;
            case TOUCH_DATA_COMMON_DRIFT_HOLD_INTERVAL:
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
                ASSERT(p_arg->size >= sizeof(uint16_t));
#endif
                memcpy(p_arg->p_dest, &pctrl->drift_hold_limit, sizeof(uint16_t));
                break;
            case TOUCH_DATA_COMMON_DRIFT_HOLD_COUNTER:
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
                ASSERT(p_arg->size >= sizeof(uint16_t));
#endif
                memcpy(p_arg->p_dest, &pctrl->drift_hold_count, sizeof(uint16_t));
                break;
            case TOUCH_DATA_COMMON_CONTINUOUS_ON_INTERVAL:
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
                ASSERT(p_arg->size >= sizeof(uint16_t));
#endif
                memcpy(p_arg->p_dest, &pctrl->on_limit, sizeof(uint16_t));
                break;
            case TOUCH_DATA_COMMON_CONTINUOUS_ON_COUNTER:
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
                ASSERT(p_arg->size >= sizeof(uint16_t));
#endif
                memcpy(p_arg->p_dest, &pctrl->on_count, sizeof(uint16_t));
                break;
            case TOUCH_DATA_HANDLE_LOCK:
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
                ASSERT(p_arg->size >= sizeof(pctrl->lock));
#endif
                memcpy(p_arg->p_dest, &pctrl->lock, sizeof(pctrl->lock));
                break;
            case TOUCH_DATA_SENSOR_OFFSET:
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
                ASSERT(p_arg->size >= (p_arg->sensor_count * sizeof(uint16_t)));
#endif
                for(itr = 0; itr < p_arg->sensor_count; itr++)
                {
                    uint16_t * p_result = p_arg->p_dest;
                    p_result[itr] = get_sensor_offset(pctrl, p_arg->sensor[itr].rx, p_arg->sensor[itr].tx);
                }
                break;
            default:
                touch_err = read_sensor_parameter(pctrl, p_arg);
                break;
        }
    }

    return touch_err;
}
/***********************************************************************************************************************
End of function R_TOUCH_Read
***********************************************************************************************************************/

/***********************************************************************************************************************
* Function Name: R_TOUCH_Control
* Description  : Change parameters of associated with a control block and related sensors
* Arguments    : id -
*                   Identifier returned by a successful call to R_TOUCH_Open
*                p_arg -
*                    Structure identifying which parameter to change and the value to
*                    change to. If parameter is a sensor setting, the tx and rx electrode
*                    information for the sensor must be provided.
* Return Value : TOUCH_SUCCESS, TOUCH_ERR_LOCKED, TOUCH_ERR_INVALID_CMD, TOUCH_ERR_INVALID_PARAM.
***********************************************************************************************************************/
touch_err_t R_TOUCH_Control(touch_ctrl_t * const p_ctrl, touch_control_arg_t const * const p_arg)
{
    touch_err_t touch_err = TOUCH_SUCCESS;
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
    ASSERT(NULL!=p_arg->p_dest);
    ASSERT(TOUCH_DATA_LAST > p_arg->cmd);
#endif
    touch_instance_ctrl_t * const pctrl = p_ctrl;
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
    ASSERT(OPEN == pctrl->open);
#endif
    /** a. Check resource lock */
    if( SSP_SUCCESS !=R_BSP_SoftwareLock(&pctrl->lock) )
    {
        /* Other API is busy with this handle. */
        return TOUCH_ERR_LOCKED;
    }

    if (TOUCH_DATA_CTSU_HW_IDENTIFIER == p_arg->cmd)
    {
        memcpy((void*)&pctrl->p_ctsu, p_arg->p_dest, sizeof(pctrl->p_ctsu));
    }
    else if (TOUCH_DATA_OPERATION_FLAGS == p_arg->cmd)
    {
        touch_err = write_sensor_parameter(pctrl, p_arg);
    }
    else if( (p_arg->cmd >= TOUCH_DATA_FILTERED_COUNT) &&
            (p_arg->cmd <= TOUCH_DATA_LAST))
    {
        touch_err = write_sensor_parameter(pctrl, p_arg);
    }
    else
    {
        switch(p_arg->cmd)
        {
            case TOUCH_DATA_COMMON_DRIFT_HOLD_INTERVAL:
                memcpy((void*)&pctrl->drift_hold_limit, p_arg->p_dest, sizeof(uint16_t));
                break;

            case TOUCH_DATA_COMMON_DRIFT_HOLD_COUNTER:
                memcpy(&pctrl->drift_hold_count, p_arg->p_dest, sizeof(uint16_t));
                break;

            case TOUCH_DATA_COMMON_CONTINUOUS_ON_INTERVAL:
                memcpy((void*)&pctrl->on_limit, p_arg->p_dest, sizeof(uint16_t));
                break;

            case TOUCH_DATA_COMMON_CONTINUOUS_ON_COUNTER:
                memcpy(&pctrl->on_count, p_arg->p_dest, sizeof(uint16_t));
                break;

            default:
                touch_err = TOUCH_ERR_INVALID_CMD;
                break;
        }
    }

    /* Unlock the block */
    R_BSP_SoftwareUnlock(&pctrl->lock);

    return touch_err;
}
/***********************************************************************************************************************
End of function R_TOUCH_Control
***********************************************************************************************************************/

/***********************************************************************************************************************
* Function Name: R_TOUCH_Calibrate
* Description  : Calibrate the specified control block.
* Arguments    : id -
*                   Identifier returned by a successful call to R_TOUCH_Open
* Return Value : TOUCH_SUCCESS, TOUCH_ERR_AUTO_TUNE_FAILED, TOUCH_ERR_INVALID_PARAM
***********************************************************************************************************************/
touch_err_t R_TOUCH_Calibrate(touch_ctrl_t * const p_ctrl)
{
    touch_err_t touch_err = TOUCH_SUCCESS;
    touch_instance_ctrl_t * const pctrl = p_ctrl;
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
    ASSERT(OPEN == pctrl->open);
#endif
    ctsu_err_t ctsu_err;
    uint8_t ignore_itr = 0;
    touch_sensor_t * p_ignore;
    uint16_t itr_ignored = 0;
    uint16_t itr;
    uint16_t ctsusc_primary;
    uint16_t ctsurc_primary;
    uint16_t ctsuso;
    ctsu_read_t ctsu_read_args = {
        .size = sizeof(uint16_t),
        .count = 1,
        .sensor_offset = &itr,
    };

    ctsu_control_arg_ext_t ctsu_control_arg_ext;

    ctsu_control_arg_t ctsu_control_arg = {
        .p_context = &ctsu_control_arg_ext,
    };
    uint16_t error_count = 0;
    uint16_t num_tuned_sensors = 0;
    uint16_t num_sensors_to_tune = (uint16_t)(pctrl->num_sensors - pctrl->num_ignored);

    ctsu_err = pctrl->p_ctsu->p_api->calibrate(pctrl->p_ctsu->p_ctrl);

#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
    ASSERT(CTSU_SUCCESS==ctsu_err);
#endif

    while(num_tuned_sensors < num_sensors_to_tune)
    {
        num_tuned_sensors = 0;

        if(error_count > MAX_ERROR_COUNT)
        {
            /* Too many errors in scanning */
            touch_err = TOUCH_ERR_AUTO_TUNE_FAILED;
            break;
        }
        touch_err = R_TOUCH_StartScan(p_ctrl);
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
        ASSERT(TOUCH_SUCCESS==touch_err);
#endif
        /* Wait for scan to complete */
        while (R_BSP_SoftwareLock(&pctrl->lock) != SSP_SUCCESS)
        {
            /* GSCE CODAN Elimination: Do Nothing */;
        }

        if(pctrl->scan_errors > 0)
        {
            /* Unlock the block & try re-scanning. */
            error_count = (uint16_t)(error_count + 1U);
            R_BSP_SoftwareUnlock(&pctrl->lock);
            continue;
        }

        ignore_itr = 0;
        p_ignore = (touch_sensor_t*)&pctrl->p_ignored[ignore_itr];
        if(pctrl->num_ignored > 0)
        {
            itr_ignored = get_sensor_offset(pctrl, p_ignore->rx, p_ignore->tx);
            ignore_itr = (uint8_t)(ignore_itr + 1U);
        }

        for(itr = 0; itr < pctrl->num_sensors; itr++)
        {
            /* Read sensor results*/
            if((pctrl->num_ignored > 0) && (itr == itr_ignored))
            {
                /* Get the next iteration to ignore */
                p_ignore = (touch_sensor_t*)&pctrl->p_ignored[ignore_itr];
                itr_ignored = get_sensor_offset(pctrl, p_ignore->rx, p_ignore->tx);
                ignore_itr = (uint8_t)(ignore_itr + 1U);

                /* Skip remaining actions*/
                continue;
            }
            ctsu_read_args.p_dest = &ctsusc_primary;
            ctsu_read_args.ctsu_result = CTSU_READ_SENSOR_COUNT_PRIMARY;

            ctsu_err = pctrl->p_ctsu->p_api->read(pctrl->p_ctsu->p_ctrl, &ctsu_read_args);
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
            ASSERT(CTSU_SUCCESS==ctsu_err);
#endif
            ctsu_read_args.p_dest = &ctsurc_primary;
            ctsu_read_args.ctsu_result = CTSU_READ_REFERENCE_COUNT_PRIMARY;

            ctsu_err = pctrl->p_ctsu->p_api->read(pctrl->p_ctsu->p_ctrl, &ctsu_read_args);
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
            ASSERT(CTSU_SUCCESS==ctsu_err);
#endif
            int16_t abs_del = abs(ctsusc_primary - ctsurc_primary) & INT16_MAX;
            if( abs_del > (TUNING_UPPER_LIMIT + TUNING_LOWER_LIMIT))
            {
                /* Counter values outside range */
                ctsu_control_arg.cmd = CTSU_CMD_GET_CTSUSO0;
                ctsu_control_arg_ext.offset = itr;
                ctsu_control_arg_ext.value = 0;

                ctsu_err = pctrl->p_ctsu->p_api->control(pctrl->p_ctsu->p_ctrl, &ctsu_control_arg);
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
                ASSERT(CTSU_SUCCESS==ctsu_err);
#endif
                ctsuso = ctsu_control_arg_ext.value & 0x3FF;
                if(ctsusc_primary > ctsurc_primary)
                {
                    ctsuso = (uint16_t)(ctsuso + ((ctsuso < 0x3FF) ? 1U:0));
                }
                else if (ctsusc_primary < ctsurc_primary)
                {
                    ctsuso = (uint16_t)(ctsuso - ((ctsuso > 0) ? 1U : 0));
                }
                else
                {
                    /* GSCE CODAN Error Elimination : Do Nothing */
                }

                if ((0 == ctsuso) || (0x3FF == ctsuso))
                {
                    /* This is not going to make much difference */
                    num_tuned_sensors = (uint16_t)(num_tuned_sensors + 1U);
                    continue;
                }
                ctsu_control_arg_ext.value &= (uint16_t)~0x3FF;
                ctsu_control_arg_ext.value |= ctsuso;

                ctsu_control_arg.cmd = CTSU_CMD_SET_CTSUSO0;
                ctsu_err = pctrl->p_ctsu->p_api->control(pctrl->p_ctsu->p_ctrl, &ctsu_control_arg);
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
                ASSERT(CTSU_SUCCESS==ctsu_err);
#endif
            }
            else
            {   /* Counter values within range*/
                num_tuned_sensors = (uint16_t)(num_tuned_sensors + 1U);
                ctsu_read_args.p_dest = &pctrl->p_sensor[itr].input;
                ctsu_read_args.ctsu_result = CTSU_READ_SENSOR_OUTPUT;
                ctsu_err = pctrl->p_ctsu->p_api->read(pctrl->p_ctsu->p_ctrl, &ctsu_read_args);
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
                ASSERT(CTSU_SUCCESS==ctsu_err);
#endif
                /* Save as the baseline */
                pctrl->p_sensor[itr].baseline = pctrl->p_sensor[itr].input;
            }

        }

        /* Unlock the block */
        R_BSP_SoftwareUnlock(&pctrl->lock);
    }

    (void)ctsu_err;     // Getting rid of compiler warning.

    return touch_err;
}
/***********************************************************************************************************************
End of function R_TOUCH_Calibrate
***********************************************************************************************************************/

/***********************************************************************************************************************
* Function Name: already_open
* Description  : Checks if a matching control block exists in array @ref pvt_touch_ctrl_blk. Uses memory compare.
* Arguments    : index -
*                    Where to start looking
*                p_ctrl -
*                   Pointer to control block being matched.
* Return Value : Index in array @ref pvt_touch_ctrl_blk.
*                   @note: Will return value > (*pvt_touch_ctrl_blk_count) if not found.
***********************************************************************************************************************/
static bool already_open(touch_instance_ctrl_t const*const p_ctrl_1, touch_instance_ctrl_t const*const p_ctrl_2)
{
    if(0==memcmp(p_ctrl_2, p_ctrl_1, offsetof(touch_instance_ctrl_t, open)))
    {
        /* Matches a previously opened block. */
        return true;
    }

    return false;
}
/***********************************************************************************************************************
End of function already_open
***********************************************************************************************************************/

/***********************************************************************************************************************
* Function Name: is_touched
* Description  : Determines if a sensor is touched or not.
* Arguments    : p_arg -
*                    Pointer to location holding arguments passed to this function. (Type-cast to: touch_detect_t)
* Return Value : true - Indicating Sensor is touched
*                   false - Indicating Sensor is not touched.
***********************************************************************************************************************/
static bool is_touched(void * p_arg)
{
    touch_detect_t * p_sensor = p_arg;
    uint16_t const  threshold =     p_sensor->threshold;
    uint16_t const  hysteresis =    p_sensor->hysteresis;
    uint8_t const   dt_limit =  p_sensor->dt_limit;
    uint8_t const   dr_limit = p_sensor->dr_limit;

    uint16_t input      = p_sensor->input    ;
    uint16_t baseline   = p_sensor->baseline ;
    uint16_t dt_count   = p_sensor->dt_count ;
    uint16_t dr_count   = p_sensor->dr_count ;

    int32_t abs_delta = abs(input-baseline);

    /* Touch detection operation */
    if(abs_delta > threshold)
    {
        dt_count = (uint16_t)(dt_count + ((dt_count < dt_limit ) ? 1U: 0));
        if(dt_count >= dt_limit)
        {
            /* Latch to TOUCHED state */
            dr_count = dr_limit;
        }
    }
    else if (abs_delta < abs (threshold - hysteresis))
    {
        dr_count = (uint16_t)((dr_count > 0) ? (dr_count - 1U) : 0);
        if (0 == dr_count)
        {
            dt_count = 0;
        }
    }
    else
    {
        /* GSCE CODAN Error elimination: Do Nothing */
    }

    /* Save all parameters that can change in this block */
    p_sensor->dt_count  = dt_count  ;
    p_sensor->dr_count  = dr_count  ;
    p_sensor->delta = (uint16_t)abs_delta;

    if(dt_count >= dt_limit)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}
/***********************************************************************************************************************
End of function is_touched
***********************************************************************************************************************/

/***********************************************************************************************************************
* Function Name: sensor_drift_adjust
* Description  : Drift Compensation algorithm for a given sensor.
* Arguments    : p_arg -
*                    Pointer to location holding arguments passed to this function. (Type-cast to: drift_adjust_t)
* Return Value : None
***********************************************************************************************************************/
static void sensor_drift_adjust(void * p_arg)
{
    drift_adjust_t * p_drift_args = p_arg;
#if (TOUCH_CFG_VARIABLE_DRIFT_RATES==1)
    uint8_t const add_int = p_drift_args->add_int;
    uint8_t const sub_int = p_drift_args->sub_int;
#endif
    uint16_t interval = p_drift_args->interval;

    uint16_t count      = p_drift_args->count;
    uint16_t input      = p_drift_args->input;
    uint16_t avg_input  = p_drift_args->avg_input;
    uint16_t baseline   = p_drift_args->baseline;
    uint16_t max_input  = p_drift_args->max_input;
    uint16_t min_input  = p_drift_args->min_input;


    /* Accumulate the input */
    avg_input = (uint16_t)((avg_input >> 1) + (input >> 1));
    max_input = (input > max_input) ? (input):(max_input);
    min_input = (input < min_input) ? (input):(min_input);
    count = (uint16_t)(count + ((count < interval) ? 1: 0));


    if(count >= interval)
    {
        /* Adjust the baseline */
#if (TOUCH_CFG_VARIABLE_DRIFT_RATES==1)
        if(p_drift_args->mode==CTSU_MODE_SELF_CAPACITANCE)
        {
            if(avg_input < baseline)
            {
                interval += (interval < (UINT16_MAX-add_int)) ? add_int : 0;
            }
            else if(avg_input > baseline)
            {
                interval -= (interval < (2 + sub_int) ) ? sub_int : 0;
            }
        }
        else if(p_drift_args->mode==CTSU_MODE_MUTUAL_CAPACITANCE)
        {
            if(avg_input > baseline)
            {
                interval += ((interval + add_int) < UINT16_MAX) ? add_int : 0;
            }
            else if(avg_input < baseline)
            {
                interval -= ((interval - sub_int) < 2) ? sub_int : 0;
            }
        }
#endif/*(TOUCH_CFG_VARIABLE_DRIFT_RATES==1) */
        baseline = avg_input;
        min_input = max_input = baseline;
        count = 0;
    }

    /* Save all parameters that can change in this block */
    p_drift_args->count     = count;
    p_drift_args->avg_input = avg_input;
    p_drift_args->baseline  = baseline;
    p_drift_args->max_input = max_input;
    p_drift_args->min_input = min_input;
    p_drift_args->interval = interval;

    return;
}
/***********************************************************************************************************************
End of function sensor_drift_adjust
***********************************************************************************************************************/

/***********************************************************************************************************************
* Function Name: sensor_optimize_sensitivity
* Description  : Optimizes the sensitivity of a Touch Sensor by modifying the CTSUSO value.
* Arguments    : p_arg -
*                    Pointer to location holding arguments passed to this function. (Type-cast to: sensor_optimize_t)
* Return Value : None
***********************************************************************************************************************/
static void sensor_optimize_sensitivity(void * p_arg)
{
    ctsu_err_t ctsu_err;
    ctsu_control_arg_t arg;
    ctsu_control_arg_ext_t arg_ext;

    sensor_optimize_t * p_optimize_args = p_arg;

    uint16_t ctsuso = 0;
    uint16_t const interval     = p_optimize_args->interval;
    uint16_t  const threshold   = p_optimize_args->threshold;
    uint16_t const sen_cnt_pri  = p_optimize_args->sen_cnt_pri;
    uint16_t const ref_cnt_pri  = p_optimize_args->ref_cnt_pri;

    uint16_t count              = p_optimize_args->count;
    uint16_t avg_sen_cnt_pri    = p_optimize_args->avg_sen_cnt_pri;
    uint16_t avg_ref_cnt_pri    = p_optimize_args->avg_ref_cnt_pri;

    avg_sen_cnt_pri = (uint16_t)((avg_sen_cnt_pri >> 1) + (sen_cnt_pri >> 1));
    avg_ref_cnt_pri = (uint16_t)((avg_ref_cnt_pri >> 1) + (ref_cnt_pri >> 1));

    int32_t abs_delta = abs(sen_cnt_pri - ref_cnt_pri);

    count = (uint16_t)(( abs_delta > threshold ) ? (count+1U): 0);

    if(count > interval)
    {
        /* Perform re-calibration */
        arg.cmd = CTSU_CMD_GET_CTSUSO0;
        arg_ext.value = 0;
        arg_ext.offset = p_optimize_args->sensor_offset;
        arg.p_context = &arg_ext;

        ctsu_err = p_optimize_args->p_ctsu->p_api->control(p_optimize_args->p_ctsu->p_ctrl, &arg);
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
        ASSERT(CTSU_SUCCESS == ctsu_err);
#endif
        ctsuso = arg_ext.value & 0x3FF;

        if(avg_sen_cnt_pri > avg_ref_cnt_pri)
        {
            ctsuso = (uint16_t)(ctsuso + ((ctsuso < 0x3FE) ? 1:0));
        }
        else if(avg_sen_cnt_pri < avg_ref_cnt_pri)
        {
            ctsuso = (uint16_t)(ctsuso - ((ctsuso > 1U) ? 1:0));
        }
        else
        {
            /* GSCE CODAN Error: Do Nothing. */
        }

        avg_sen_cnt_pri = sen_cnt_pri;
        avg_ref_cnt_pri = ref_cnt_pri;

        arg_ext.value &= (uint16_t)~0x3FFU;
        arg_ext.value |= ctsuso;

        arg.cmd = CTSU_CMD_SET_CTSUSO0;
        ctsu_err = p_optimize_args->p_ctsu->p_api->control(p_optimize_args->p_ctsu->p_ctrl, &arg);
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
        ASSERT(CTSU_SUCCESS == ctsu_err);
#endif
        count = 0;
    }

    /* Save all parameters that can change in this block */
    p_optimize_args->count = count;
    p_optimize_args->avg_sen_cnt_pri = avg_sen_cnt_pri;
    p_optimize_args->avg_ref_cnt_pri = avg_ref_cnt_pri;

    (void)ctsu_err; //Gets rid of compiler warning.

    return;
}
/***********************************************************************************************************************
End of function sensor_optimize_sensitivity
***********************************************************************************************************************/

/***********************************************************************************************************************
* Function Name: filter_2n_lpraf
* Description  : Implements a pow(2,n) L-Point Running Average Filter.
* Arguments    : p_arg -
*                    Pointer to location holding arguments passed to this filter. (Type-cast to: filter_args_t)
* Return Value : None
***********************************************************************************************************************/
static void filter_2n_lpraf(void* p_arg)
{
    /**
     * Filter power when using a l-point running average filter.
     */
    static uint8_t const filter_power = 3;

    filter_args_t * p_filter_arg = p_arg;

    uint8_t power = filter_power;
    uint16_t input = p_filter_arg->input;
    uint16_t output = p_filter_arg->output;

    output = (uint16_t)(output - (output >> power));
    input = (uint16_t)(input >> power);

    output = (uint16_t)(output + input);

    p_filter_arg->output = output;

}
/***********************************************************************************************************************
End of function filter_2n_lpraf
***********************************************************************************************************************/

/***********************************************************************************************************************
* Function Name: filter
* Description  : Filters data for all sensors in a control block.
* Arguments    :
*                p_ctrl -
*                    Pointer to a valid control block.
* Return Value : N/A
***********************************************************************************************************************/
static ctsu_err_t filter(touch_instance_ctrl_t * const p_ctrl)
{
    uint16_t itr;
    uint16_t num_sensors = p_ctrl->num_sensors;
    touch_operation_t action;
    ctsu_err_t ctsu_err;
    for(itr = 0; (itr < num_sensors) ; itr++)
    {
        filter_args_t filter_arg = {
            .itr = itr,
            .input = 0,
            .output = (p_ctrl->p_sensor[itr].input > 0) ?
                    (p_ctrl->p_sensor[itr].input) :
                    ((CTSU_MODE_MUTUAL_CAPACITANCE == p_ctrl->mode) ?
                            (UINT16_MAX):(0)),
            .p_instance = p_ctrl->p_sensor[itr].p_filter_state,
        };
        ctsu_read_t read_arg = {
                .ctsu_result = CTSU_READ_SENSOR_OUTPUT,
                .p_dest = (void*)&filter_arg.input,
                .size = sizeof(uint16_t),
                .count = 1,
                .sensor_offset = &itr,
        };
        ctsu_err = p_ctrl->p_ctsu->p_api->read(p_ctrl->p_ctsu->p_ctrl, &read_arg);

        if(CTSU_SUCCESS==ctsu_err)
        {
            /* Perform filtering */
            action.byte = p_ctrl->p_sensor[itr].operation.byte;
            if (true == action.bit.filter)
            {
                p_ctrl->p_filter(&filter_arg);

                /* Save parameters that can be changed by the algorithm */
                p_ctrl->p_sensor[itr].input = filter_arg.output;
            }
            else
            {   /* Filter is bypassed; output == input */
                p_ctrl->p_sensor[itr].input = filter_arg.input;
            }
        }
        else
        {
            return ctsu_err;
        }
    }

    return CTSU_SUCCESS;
}
/***********************************************************************************************************************
End of function filter
***********************************************************************************************************************/

/***********************************************************************************************************************
* Function Name: sensors_touched
* Description  : Perform Touch Detection on sensors of a control block
* Arguments    : p_ctrl -
*                    Pointer to a valid and locked control block.
* Return Value : Number of sensors touched.
***********************************************************************************************************************/
static uint16_t sensors_touched(touch_instance_ctrl_t * const p_ctrl)
{
    uint16_t itr;
    touch_operation_t action;
    uint8_t bit_mask;
    uint8_t bit_offset;
    uint8_t byte_offset;
    bool touched = false;
    uint16_t instant_touched_sensor_count = 0;
    uint16_t num_touched_sensors = 0;
    uint16_t num_sensors = p_ctrl->num_sensors;

    for(itr = 0; (itr < num_sensors); itr++)
    {
        action.byte = p_ctrl->p_sensor[itr].operation.byte;
        if (true == action.bit.detection)
        {
            byte_offset = (uint8_t)(itr>>3);
            bit_offset  = itr & 7;
            bit_mask = (uint8_t)(1<<bit_offset);
            touch_detect_t detect_arg = {
                .input = p_ctrl->p_sensor[itr].input,
                .baseline = (0 == p_ctrl->p_sensor[itr].baseline) ? (p_ctrl->p_sensor[itr].input):(p_ctrl->p_sensor[itr].baseline),
                .threshold = p_ctrl->p_sensor[itr].p_touch_sensor->threshold,
                .hysteresis = p_ctrl->p_sensor[itr].p_touch_sensor->hysteresis,
                .dt_limit = p_ctrl->p_sensor[itr].p_touch_sensor->dt_limit,
                .dr_limit = p_ctrl->p_sensor[itr].p_touch_sensor->dr_limit,
                .dt_count = p_ctrl->p_sensor[itr].dt_count,
                .dr_count = p_ctrl->p_sensor[itr].dr_count,
            };

            /* Limit (mode-dependent) negative-input */
            if (CTSU_MODE_SELF_CAPACITANCE == p_ctrl->mode)
            {
                uint16_t input = (detect_arg.input > detect_arg.baseline) ?
                        (detect_arg.input):(detect_arg.baseline);
                memcpy((void*)&detect_arg.input, (void*)&input, sizeof(detect_arg.input));
            }
            else
            {
                uint16_t input = (detect_arg.input < detect_arg.baseline) ?
                        (detect_arg.input):(detect_arg.baseline);
                memcpy((void*)&detect_arg.input, (void*)&input, sizeof(detect_arg.input));
            }

            /* Perform touch Detection */
            touched = p_ctrl->p_touch_detect(&detect_arg);

            /* Save parameters that can be changed by the algorithm */
            p_ctrl->p_sensor[itr].dt_count = (uint8_t)(detect_arg.dt_count);
            p_ctrl->p_sensor[itr].dr_count = (uint8_t)(detect_arg.dr_count);
            p_ctrl->p_sensor[itr].delta =  detect_arg.delta;
            if(detect_arg.dt_count > 0)
            {
                /* Sensor is going through debounce routine/ latched to touched */
                instant_touched_sensor_count = (uint16_t)(instant_touched_sensor_count + 1U);
            }
            if(true==touched)
            {
                /* Set bit-mask */
                num_touched_sensors = (uint16_t)(num_touched_sensors + 1U);
                p_ctrl->p_binary_result[byte_offset] |= bit_mask;
            }
            else
            {   /* Clear bit-mask */
                p_ctrl->p_binary_result[byte_offset] = (uint8_t)(p_ctrl->p_binary_result[byte_offset] & (~bit_mask));
            }
        }
    }
#if (TOUCH_CFG_MULTITOUCH_REJECTION_TYPE==1)
    if(instant_touched_sensor_count > p_ctrl->max_touched_sensors)
    {
        num_touched_sensors = 0;
    }
#elif (TOUCH_CFG_MULTITOUCH_REJECTION_TYPE==2)
    if(num_touched_sensors > p_ctrl->max_touched_sensors)
    {
        num_touched_sensors = 0;
    }
#elif (TOUCH_CFG_MULTITOUCH_REJECTION_TYPE==3)
    if((int16_t)(num_touched_sensors-p_ctrl->num_touched) > (int16_t)p_ctrl->max_touched_sensors)
    {
        num_touched_sensors = 0;
    }
#endif

    if((num_touched_sensors > 1) && (num_touched_sensors < p_ctrl->max_touched_sensors))
    {
        p_ctrl->multi_touch = true;
    }
    else
    {
        p_ctrl->multi_touch = false;
    }

#if (TOUCH_CFG_MULTITOUCH_REJECTION_TYPE > 0)
    for (uint16_t itr = 0; (itr < p_ctrl->num_sensors) && (true == p_ctrl->multi_touch); itr += 8)
    {
        /* Multi-touch detected. Binary mask becomes 0. */
        p_ctrl->p_binary_result[itr>>3] = 0;
    }
#endif

    return num_touched_sensors;
}
/***********************************************************************************************************************
End of function sensors_touched
***********************************************************************************************************************/

/***********************************************************************************************************************
* Function Name: drift_compensation
* Description  : Perform drift compensation for sensors in a control block.
* Arguments    : p_ctrl -
*                    Pointer to a valid and locked control block.
* Return Value : None
***********************************************************************************************************************/
static void drift_compensation(touch_instance_ctrl_t * const p_ctrl)
{
    uint16_t itr;

    touch_operation_t action;
    uint16_t num_sensors = p_ctrl->num_sensors;

    for(itr = 0; (itr < num_sensors); itr++)
    {
#if (TOUCH_CFG_COMPENSATE_WHILE_TOUCHED==true)
        if(p_ctrl->drift_hold_count > 0)
        {
            /* Request to shut-off drift compensation (all sensors, n-scans). */
            continue;
        }
#else
        if((p_ctrl->num_touched > 0) && (p_ctrl->on_count < p_ctrl->on_limit))
        {
            /* Do not drift compensate any sensors while a sensor is TOUCHED */
            break;
        }
#endif

        if ((p_ctrl->on_count > p_ctrl->on_limit)
#if (TOUCH_CFG_MULTITOUCH_REJECTION_TYPE > 0)
                || (true == p_ctrl->multi_touch)
#endif
                )
        {
            /* Synchronize all sensors. */
            p_ctrl->p_sensor[itr].dt_count = 0;
            p_ctrl->p_sensor[itr].dr_count = 0;
            p_ctrl->p_sensor[itr].avg_input = 0;
            p_ctrl->p_sensor[itr].drift_counter = 0;
            p_ctrl->p_sensor[itr].max_input = p_ctrl->p_sensor[itr].input;
            p_ctrl->p_sensor[itr].min_input = p_ctrl->p_sensor[itr].input;
            p_ctrl->p_sensor[itr].baseline = p_ctrl->p_sensor[itr].input;
            continue;
        }

        if(p_ctrl->p_sensor[itr].dt_count > 0)
        {
            /* Skip drift compensation if sensor is touched. */
            continue;
        }

        action.byte = p_ctrl->p_sensor[itr].operation.byte;
        if (false == action.bit.drift_comp)
        {
            /* Skip to next sensor */
            continue;
        }

        drift_adjust_t drift_args =
        {
#if (TOUCH_CFG_VARIABLE_DRIFT_RATES==1)
            .add_int = 0,
            .sub_int = 0,
            .mode = 0,
#endif
            .input = p_ctrl->p_sensor[itr].input,
#if (TOUCH_CFG_VARIABLE_DRIFT_RATES==1)
            .interval = p_ctrl->p_sensor[itr].drift_interval,
#else
            .interval = p_ctrl->p_sensor[itr].p_touch_sensor->drift_rate,
#endif
            .count      =   p_ctrl->p_sensor[itr].drift_counter,
            .avg_input  =   p_ctrl->p_sensor[itr].avg_input,
            .baseline   =   p_ctrl->p_sensor[itr].baseline,
            .max_input  =   p_ctrl->p_sensor[itr].max_input,
            .min_input  =   p_ctrl->p_sensor[itr].min_input,
        };

        /* Perform drift compensation */
        sensor_drift_adjust(&drift_args);
#if (TOUCH_CFG_VARIABLE_DRIFT_RATES==1)
        p_ctrl->p_sensor[itr].drift_interval = drift_args.interval;
#endif
        /* Save parameters that can be changed by the algorithm */
        p_ctrl->p_sensor[itr].drift_counter = drift_args.count    ;
        p_ctrl->p_sensor[itr].avg_input     = drift_args.avg_input;
        p_ctrl->p_sensor[itr].baseline      = drift_args.baseline ;
        p_ctrl->p_sensor[itr].max_input     = drift_args.max_input;
        p_ctrl->p_sensor[itr].min_input     = drift_args.min_input;

    }
}
/***********************************************************************************************************************
End of function drift_compensation
***********************************************************************************************************************/

/***********************************************************************************************************************
* Function Name: sensitivity_optimization
* Description  : Optimize sensitivity for all sensors in a control block.
* Arguments    : p_ctrl -
*                    Pointer to a valid control block.
* Return Value : count -
*                    How many entries were found
***********************************************************************************************************************/
static ctsu_err_t sensitivity_optimization(touch_instance_ctrl_t * const p_ctrl)
{
    uint16_t itr;
    ctsu_err_t ctsu_err;
    touch_operation_t action;
    uint16_t num_sensors = p_ctrl->num_sensors;

    if(p_ctrl->num_touched > 0)
    {
        /* Do not optimize any sensors while TOUCHED */
        return CTSU_SUCCESS;
    }

    for(itr = 0; (itr < num_sensors); itr++)
    {
        action.byte = p_ctrl->p_sensor[itr].operation.byte;

        if ((true == action.bit.sensor_optimize)
                && (p_ctrl->p_sensor[itr].dt_count <= 0)
                )
        {
            /* Sensitivity optimization is enabled */
            sensor_optimize_t optimize_args =
            {
                .p_ctsu = p_ctrl->p_ctsu,
                .sensor_offset = itr,
                .input = p_ctrl->p_sensor[itr].input,
                .baseline = p_ctrl->p_sensor[itr].baseline,
                .interval = (uint16_t)(p_ctrl->p_sensor[itr].p_touch_sensor->recalib_delay),
                .threshold = p_ctrl->p_sensor[itr].p_touch_sensor->recalib_threshold,
                .count = p_ctrl->p_sensor[itr].recalib_counter,
                .avg_sen_cnt_pri = p_ctrl->p_sensor[itr].avg_sen_cnt_pri,
                .avg_ref_cnt_pri = p_ctrl->p_sensor[itr].avg_ref_cnt_sec,
            };

            ctsu_read_t read_arg = {
                .ctsu_result = CTSU_READ_SENSOR_COUNT_PRIMARY,
                .p_dest = (void*)&optimize_args.sen_cnt_pri,
                .size = sizeof(uint16_t),
                .count = 1,
                .sensor_offset = &itr,
            };

            ctsu_err = p_ctrl->p_ctsu->p_api->read(p_ctrl->p_ctsu->p_ctrl, &read_arg);
            if(CTSU_SUCCESS==ctsu_err)
            {
                read_arg.p_dest = (void*)&optimize_args.ref_cnt_pri;
                read_arg.ctsu_result = CTSU_READ_REFERENCE_COUNT_PRIMARY;
            }
            else
            {
                return ctsu_err;
            }
            ctsu_err = p_ctrl->p_ctsu->p_api->read(p_ctrl->p_ctsu->p_ctrl, &read_arg);

            if(CTSU_SUCCESS==ctsu_err)
            {
                /* CTSU Sensitivity Optimization */
                sensor_optimize_sensitivity(&optimize_args);
            }
            else
            {
                return ctsu_err;
            }

            /* Save parameters that can be changed by the algorithm */
            p_ctrl->p_sensor[itr].recalib_counter = optimize_args.count;
            p_ctrl->p_sensor[itr].avg_sen_cnt_pri = optimize_args.avg_sen_cnt_pri;
            p_ctrl->p_sensor[itr].avg_ref_cnt_sec = optimize_args.avg_ref_cnt_pri;
        }
    }

    return CTSU_SUCCESS;
}
/***********************************************************************************************************************
End of function sensitivity_optimization
***********************************************************************************************************************/

/***********************************************************************************************************************
* Function Name: get_byte_offset_and_size
* Description  : Get the offset and size of a member in sensor_info_t.
* Arguments    : cmd -
*                    Member name being accessed.
*                p_size -
*                    Pointer to where the size must be placed.
* Return Value : Offset of member (in bytes)
***********************************************************************************************************************/
static size_t get_byte_offset_and_size(touch_data_t cmd, size_t* p_size)
{
    size_t byte_offset = 0;
    size_t unit_size = 0;

    switch(cmd)
    {
        case TOUCH_DATA_OPERATION_FLAGS:
            byte_offset = offsetof(sensor_info_t, operation);
            unit_size = sizeof(touch_operation_t);
            break;

        case TOUCH_DATA_FILTERED_COUNT:
            byte_offset = offsetof(sensor_info_t, input);
            unit_size = sizeof(uint16_t);
            break;

        case TOUCH_DATA_DELTA_COUNT:
            byte_offset = offsetof(sensor_info_t, delta);
            unit_size = sizeof(uint16_t);
            break;

        case TOUCH_DATA_BASELINE_COUNT:
            byte_offset = offsetof(sensor_info_t, baseline);
            unit_size = sizeof(uint16_t);
            break;

        case TOUCH_DATA_DELAY_TO_TOUCH_COUNTER:
            byte_offset = offsetof(sensor_info_t, dt_count);
            unit_size = sizeof(uint8_t);
            break;

        case TOUCH_DATA_DELAY_TO_RELEASE_COUNTER:
            byte_offset = offsetof(sensor_info_t, dr_count);
            unit_size = sizeof(uint8_t);
            break;

        case TOUCH_DATA_AVERAGE_INPUT:
            byte_offset = offsetof(sensor_info_t, avg_input);
            unit_size = sizeof(uint16_t);
            break;

        case TOUCH_DATA_MINIMUM_INPUT:
            byte_offset = offsetof(sensor_info_t, min_input);
            unit_size = sizeof(uint16_t);
            break;

        case TOUCH_DATA_MAXIMUM_INPUT:
            byte_offset = offsetof(sensor_info_t, max_input);
            unit_size = sizeof(uint16_t);
            break;

        case TOUCH_DATA_DRIFT_COUNTER:
            byte_offset = offsetof(sensor_info_t, drift_counter);
            unit_size = sizeof(uint16_t);
            break;

#if (TOUCH_CFG_VARIABLE_DRIFT_RATES==1)
        case TOUCH_DATA_DRIFT_INTERVAL:
            byte_offset = offsetof(sensor_info_t, drift_interval);
            unit_size = sizeof(uint16_t);
            break;
#endif

        case TOUCH_DATA_AVG_SEN_COUNTER_PRI:
            byte_offset = offsetof(sensor_info_t, avg_sen_cnt_pri);
            unit_size = sizeof(uint16_t);
            break;

        case TOUCH_DATA_AVG_REF_COUNTER_PRI:
            byte_offset = offsetof(sensor_info_t, avg_ref_cnt_sec);
            unit_size = sizeof(uint16_t);
            break;

        case TOUCH_DATA_RECALIBRATION_COUNTER:
            byte_offset = offsetof(sensor_info_t, recalib_counter);
            unit_size = sizeof(uint16_t);
            break;

        default:
            byte_offset = 0xFFFF;
            unit_size = SIZE_MAX;
            break;
    }

    *p_size = unit_size;
    return byte_offset;
}
/***********************************************************************************************************************
End of function get_byte_offset_and_size
***********************************************************************************************************************/

/***********************************************************************************************************************
* Function Name: get_sensor_offset
* Description  : Calculate offset of a sensor given Transmit and Receive electrode.
* Arguments    : p_ctrl -
*                    Pointer to Touch Control Block whose sensors are to be read.
*                rx_ch -
*                    Receive Channel
*                tx_ch -
*                    Transmit Channel
* Return Value : count -
*                    How many entries were found
***********************************************************************************************************************/
static uint16_t get_sensor_offset(touch_instance_ctrl_t * const p_ctrl, uint8_t rx_ch, uint8_t tx_ch)
{
    uint16_t sensor_offset = 0xFFFF;

    sensor_offset = (uint16_t)((CTSU_MODE_MUTUAL_CAPACITANCE == p_ctrl->mode) ?
            ((p_ctrl->offset_en[rx_ch]*p_ctrl->num_tx) + p_ctrl->offset_en[tx_ch]) :
            (p_ctrl->offset_en[rx_ch]));

    return sensor_offset;
}
/***********************************************************************************************************************
End of function get_sensor_offset
***********************************************************************************************************************/

/***********************************************************************************************************************
* Function Name: read_sensor_parameter
* Description  : Reads a parameter from the memory holding status of each sensor.
* Arguments    : p_ctrl -
*                    Pointer to Touch Control Block whose sensors are to be read.
*                p_arg -
*                    Pointer to information request.
* Return Value : count -
*                    How many entries were found
***********************************************************************************************************************/
static touch_err_t read_sensor_parameter(touch_instance_ctrl_t * const p_ctrl, touch_read_t const * const p_arg)
{
    uint16_t itr;
    uint8_t * p_sensor_base;
    size_t byte_offset;
    uint16_t sensor_offset;
    size_t unit_size;

#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
    ASSERT(TOUCH_DATA_FILTERED_COUNT <= p_arg->read_cmd);
    ASSERT(TOUCH_DATA_LAST > p_arg->read_cmd);
#endif

    uint8_t * p_dest = p_arg->p_dest;
    uint16_t const count = (NULL == p_arg->sensor) ?
            (p_ctrl->num_sensors) : (p_arg->sensor_count);

    byte_offset = get_byte_offset_and_size(p_arg->read_cmd, &unit_size);

    if((0==unit_size) || (byte_offset > sizeof(sensor_info_t)) )
    {
        /* Command not supported by this function. */
        return TOUCH_ERR_INVALID_CMD;
    }

    if(p_arg->size < (count*unit_size))
    {
        /* Check if destination has sufficient size */
        return TOUCH_ERR_INVALID_PARAM;
    }

    for(itr = 0; itr < count; itr++)
    {
        /* Locate and copy the related data */
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
    ASSERT(LAST_TS >= p_arg->sensor[itr].rx);
    if (CTSU_MODE_MUTUAL_CAPACITANCE == p_ctrl->mode)
    {
        ASSERT(LAST_TS >= p_arg->sensor[itr].tx);
    }
#endif

    if (NULL == p_arg->sensor)
    {
        sensor_offset = itr;
    }
    else
    {
        sensor_offset = get_sensor_offset(p_ctrl, p_arg->sensor[itr].rx, p_arg->sensor[itr].tx);
    }
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
        ASSERT(p_ctrl->num_sensors > sensor_offset);
#endif
        p_sensor_base = (uint8_t*)(&p_ctrl->p_sensor[sensor_offset]);
        memcpy(p_dest, (p_sensor_base + byte_offset), unit_size);
        p_dest += unit_size;
    }

    return TOUCH_SUCCESS;
}
/***********************************************************************************************************************
End of function read_sensor_parameter
***********************************************************************************************************************/

/***********************************************************************************************************************
* Function Name: write_sensor_parameter
* Description  : Writes a parameter in the memory holding status of each sensor.
* Arguments    : p_ctrl -
*                    Pointer to Touch Control Block whose sensors are to be modified.
*                p_arg -
*                    Pointer to information request.
* Return Value : count -
*                    How many entries were found
***********************************************************************************************************************/
static touch_err_t write_sensor_parameter(touch_instance_ctrl_t * const p_ctrl, touch_control_arg_t const *const p_arg)
{
    uint8_t * p_sensor_base;
    size_t byte_offset;
    uint16_t sensor_offset;
    size_t unit_size;

#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
    ASSERT(TOUCH_DATA_FILTERED_COUNT <= p_arg->cmd);
    ASSERT(TOUCH_DATA_LAST > p_arg->cmd);
#endif
    byte_offset = get_byte_offset_and_size(p_arg->cmd, &unit_size);

    if((0==unit_size) || (byte_offset > sizeof(sensor_info_t)) )
    {
        /* Command not supported by this function. */
        return TOUCH_ERR_INVALID_CMD;
    }

    sensor_offset = get_sensor_offset(p_ctrl, p_arg->sensor.rx, p_arg->sensor.tx);
#if (TOUCH_CFG_PARAM_CHECKING_ENABLE==true)
        ASSERT(p_ctrl->num_sensors > sensor_offset);
#endif
    p_sensor_base = (uint8_t*)(&p_ctrl->p_sensor[sensor_offset]);
    memcpy((p_sensor_base + byte_offset), p_arg->p_dest, unit_size);

    return TOUCH_SUCCESS;
}
/***********************************************************************************************************************
End of function write_sensor_parameter
***********************************************************************************************************************/

/***********************************************************************************************************************
* Function Name: touch_common_callback
* Description  : Does an example task. Making this longer just to see how it wraps. Making this long just to see how it
*                wraps.
* Arguments    : p_cb_arg -
*                    Pointer to Memory holding arguments being passed to function.
*                    Should be of type ctsu_callback_arg_t.
* Return Value : None
***********************************************************************************************************************/
static void touch_common_callback(ctsu_callback_arg_t const*const p_arg)
{
    uint32_t itr;
    touch_callback_arg_t arg;
    touch_instance_ctrl_t * p_ctrl;

    ctsu_event_t event = (ctsu_event_t)p_arg->event_mask;

    for(itr = 0; itr < TOUCH_CFG_MAX_OPEN_TOUCH_CONFIGS; itr++)
    {
        p_ctrl = touch_ctrl_blk[itr];

        if(OPEN != p_ctrl->open)
        {
            /* Block not open */
            continue;
        }

        if(p_ctrl->p_ctsu->p_ctrl==p_arg->handle_num)
        {
            /* Lower Level Identifier matches. */
            arg.handle_num = p_ctrl;
            arg.event = 0;
            arg.info = 0;
            if((CTSU_EVENT_SFRS_CHANGED & event)==CTSU_EVENT_SFRS_CHANGED)
            {
                arg.event = TOUCH_EVENT_REQUEST_DELAY;
                arg.info = p_ctrl->num_sensors;
            }
            else
            {
                switch(event)
                {
                    case CTSU_EVENT_STARTING_SCAN:
                        arg.event = TOUCH_EVENT_SCAN_STARTING;
                        arg.info = p_ctrl->num_sensors;
                        break;

                    case CTSU_EVENT_SCAN_COMPLETED:
                        arg.event = TOUCH_EVENT_SCAN_COMPLETE;
                        p_ctrl->scan_errors = 0;
                        if (0 != p_arg->info)
                        {
                            /* Error when scan was performed */
                            arg.info = TOUCH_ERR_CTSU_BAD_SCAN;
                            p_ctrl->scan_errors = p_arg->info;
                        }
                        break;

                    default:

                        break;
                }
            }

            if(CTSU_EVENT_SCAN_COMPLETED==event)
            {
                /* Unlock the hardware */
                R_BSP_SoftwareUnlock(&p_ctrl->lock);
            }

            for(itr = 0; itr < TOUCH_CFG_MAX_UPPER_LAYER_CALLBACKS; itr++)
            {
                if (NULL != p_ctrl->p_callback[itr])
                {
                    p_ctrl->p_callback[itr](&arg);
                }
            }
        }
    }
}
/***********************************************************************************************************************
End of function touch_common_callback
***********************************************************************************************************************/

/*******************************************************************************************************************//**
 * @} (end defgroup R_TOUCH)
 **********************************************************************************************************************/
