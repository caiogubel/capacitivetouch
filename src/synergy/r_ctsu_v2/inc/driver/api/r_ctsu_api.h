/***********************************************************************************************************************
 * DISCLAIMER
 * This software is supplied by Renesas Electronics Corporation and is only intended for use with Renesas products. No
 * other uses are authorized. This software is owned by Renesas Electronics Corporation and is protected under all
 * applicable laws, including copyright laws.
 * THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
 * THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED. TO THE MAXIMUM
 * EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES
 * SHALL BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR ANY REASON RELATED TO THIS
 * SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
 * Renesas reserves the right, without notice, to make changes to this software and to discontinue the availability of
 * this software. By using this software, you agree to the additional terms and conditions found by accessing the
 * following link:
 * http://www.renesas.com/disclaimer
 *
 * Copyright (C) 2016 Renesas Electronics Corporation. All rights reserved.
 ***********************************************************************************************************************/

/***********************************************************************************************************************
 * File Name : r_ctsu_synergy_if.h
 * Version : 1.00: Released as Version 1.00.
 * Description : This module provides the interface to the R_CTSU peripheral.
 ***********************************************************************************************************************/
/*******************************************************************************************************************//**
 * @file
 ***********************************************************************************************************************/
/*******************************************************************************************************************//**
 * @ingroup Peripheral Module Drivers
 * @defgroup R_CTSU R_CTSU
 * @brief Provides functions that can operate the Capacitive Touch Sensing Unit (CTSU). Requires @ref r_ctsu_hw.
 * @{
 * Sample Usage:
 *
 ***********************************************************************************************************************/
#ifndef R_CTSU_API_H_
#define R_CTSU_API_H_
/***********************************************************************************************************************
 Includes
 ***********************************************************************************************************************/
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

/***********************************************************************************************************************
 Macro definitions
 ***********************************************************************************************************************/
/** Version of the API defined in this file */
#define CTSU_API_VERSION_MAJOR           (01)
#define CTSU_API_VERSION_MINOR           (1)

/***********************************************************************************************************************
 Typedef definitions
 ***********************************************************************************************************************/
/** Different error status returned by the API. */
typedef enum e_ctsu_err
{
    CTSU_SUCCESS = 0,                       ///< No Errors.
    CTSU_ERR_INVALID_PARAM = 3,        ///< Received invalid information for important parameter.
    CTSU_ERR_INSUFFICIENT_MEMORY = 9,  ///< No more control blocks available.
    CTSU_ERR_CTSU_OPERATIONAL = 10,     ///< Attempted operation while CTSU is performing scan measurement.
    CTSU_ERR_LOCKED = 8,               ///< Attempted to use a locked handle.
    CTSU_ERR_INVALID_CMD = 6,          ///< Command requested is invalid.
    CTSU_ERR_CTSU_SC_OVF = 0x8010,          ///< Sensor count overflowed when performing CTSU scan.
    CTSU_ERR_CTSU_RC_OVF = 0x8020,          ///< Reference count overflowed when performing CTSU scan.
    CTSU_ERR_CTSU_ICOMP = 27,           ///< Abnormal TSCAP voltage.
    CTSU_ERR_CORRECTION_FACTOR = 18,    ///< Failed to calculate correction factor.
} ctsu_err_t;                                               ///< Refer: @ref e_ctsu_err

/** Event notifications generated by the CTSU. */
typedef enum e_ctsu_event
{
    CTSU_EVENT_SFRS_CHANGED = 1,    ///< SFR values were re-written
    CTSU_EVENT_STARTING_SCAN = 2,   ///< Scan has been started through API.
    CTSU_EVENT_SCAN_COMPLETED = 4, ///< Scan has been completed. @note This notification will be from an interrupt service routine.
} ctsu_event_t;                     ///< Refer: @ref e_ctsu_event

/** Commands which can be passed to the Control function. @note User may not logically 'OR' these. */
typedef enum e_ctsu_cmd
{
    /* Standard Get Command w/one arguments */
    CTSU_CMD_GET_MODE,                      ///< Read the mode of operation for the specified handle (ctsu_mode_t)
    CTSU_CMD_GET_PCLK,                      ///< Read the PCLK frequency at which the handle can be operated (uint32_t).
    CTSU_CMD_GET_SENSOR_COUNT,              ///< Read the number of touch sensors enabled in a handle (uint16_t).
    CTSU_CMD_GET_ERROR_INFORMATION,         ///< Read the error information from handle during last scan (uint32_t).
    CTSU_CMD_GET_RESULT_OUTPUT_BUFFER,      ///< Read the location address set for measurement data output (void*).
    CTSU_CMD_GET_CALLBACK,                  ///< Read the callback function from handle (fit_callback_t).

    /* Advanced Commands for finer control */
    CTSU_CMD_GET_CTSUCR0,                   ///< Read SFR CR0 for handle   (uint8_t).
    CTSU_CMD_GET_CTSUCR1,                   ///< Read SFR CR1 for handle   (uint8_t).
    CTSU_CMD_GET_CTSUSDPRS,                 ///< Read SFR SDPRS for handle (uint8_t).
    CTSU_CMD_GET_CTSUSST,                   ///< Read SFR SST for handle   (uint8_t).
    CTSU_CMD_GET_CTSUCHAC,                  ///< Read SFR CHAC for handle  (uint64_t).
    CTSU_CMD_GET_CTSUCHTRC,                 ///< Read SFR CHTRC for handle (uint64_t).
    CTSU_CMD_GET_CTSUDCLKC,                 ///< Read SFR DCLKC for handle (uint8_t).
    CTSU_CMD_GET_ONE_ARG_LAST,

    /* Get: w/r_ctsu_control_arg_ext_t as argument */
    CTSU_CMD_GET_CTSUSSC,                   ///< Read SFR SSC for sensor in handle(uint16_t).
    CTSU_CMD_GET_CTSUSO0,                   ///< Read SFR SO0 for sensor in handle(uint16_t).
    CTSU_CMD_GET_CTSUSO1,                   ///< Read SFR SO1 for sensor in handle(uint16_t).
    CTSU_CMD_GET_TWO_ARG_LAST,

    /* Standard Set Command w/one arguments*/
    CTSU_CMD_SET_RESULT_OUTPUT_BUFFER,      ///< Change the location address used for measurement data output (void*).
    CTSU_CMD_SET_CALLBACK,                  ///< Change the callback function for a handle(fit_callback_t).

    /* Advanced Commands for finer control */
    CTSU_CMD_SET_CTSUCR0,                   ///< Write SFR CR0 to handle   (uint8_t)
    CTSU_CMD_SET_CTSUCR1,                   ///< Write SFR CR1 to handle   (uint8_t)
    CTSU_CMD_SET_CTSUSDPRS,                 ///< Write SFR SDPRS to handle (uint8_t)
    CTSU_CMD_SET_CTSUSST,                   ///< Write SFR SST to handle   (uint8_t)
    CTSU_CMD_SET_CTSUCHAC,                  ///< Write SFR CHAC to handle  (uint64_t)
    CTSU_CMD_SET_CTSUCHTRC,                 ///< Write SFR CHTRC to handle (uint64_t)
    CTSU_CMD_SET_CTSUDCLKC,                 ///< Write SFR DCLKC to handle (uint8_t)
    CTSU_CMD_SET_ONE_ARG_LAST,

    /* Set: w/r_ctsu_control_arg_ext_t as argument */
    CTSU_CMD_SET_CTSUSSC,                   ///< Write SFR SSC to sensor in handle (uint16_t).
    CTSU_CMD_SET_CTSUSO0,                   ///< Write SFR SO0 to sensor in handle (uint16_t).
    CTSU_CMD_SET_CTSUSO1,                   ///< Write SFR SO1 to sensor in handle (uint16_t).
    CTSU_CMD_SET_TWO_ARG_LAST,
    CTSU_CMD_LAST = CTSU_CMD_SET_TWO_ARG_LAST,       ///< @note Do not use or delete!
} ctsu_cmd_t;                               ///< Refer: @ref e_ctsu_cmd

/** Commands that can be used with the @ref R_CTSU_Read function. Data unit size is 2 bytes. */
typedef enum e_ctsu_result
{
    CTSU_READ_SENSOR_COUNT_PRIMARY = 0x0, ///< Read primary sensor counts for sensors defined at @ref ctsu_read_t::sensor_offset.
    CTSU_READ_REFERENCE_COUNT_PRIMARY, ///< Read primary reference counts for sensors defined at @ref ctsu_read_t::sensor_offset.
    CTSU_READ_SENSOR_COUNT_SECONDARY, ///< Read secondary sensor counts for sensors defined at @ref ctsu_read_t::sensor_offset.
    CTSU_READ_REFERENCE_COUNT_SECONDARY, ///< Read secondary reference counts for sensors defined at @ref ctsu_read_t::sensor_offset.
    CTSU_READ_SENSOR_OUTPUT, ///< Read sensor capacitance count (depending on mode) for sensors defined at @ref ctsu_read_t::sensor_offset.
    CTSU_READ_BUFFER_ALL,                   ///< Read results buffer as is.
    CTSU_READ_LAST,                         ///< @note Do not use or delete!
} ctsu_read_cmd_t;                          ///< Refer: @ref e_ctsu_result.

/** CTSU operation modes. */
typedef enum e_ctsu_mode
{
    CTSU_MODE_NOT_SUPPORTED = 0, ///< CTSU mode is not supported by this driver. @note Use TOUCH_MODE_SELF_CAPACITANCE instead.
    CTSU_MODE_SELF_CAPACITANCE = 1,      ///< CTSU is operating in self capacitance mode.
    CTSU_MODE_PROHIBITED = 2,  ///< CTSU mode is prohibited by the MCU. @note Use TOUCH_MODE_MUTUAL_CAPACITANCE instead.
    CTSU_MODE_MUTUAL_CAPACITANCE = 3,    ///< CTSU is operating in mutual capacitance mode.
} ctsu_mode_t;                           ///< Refer: @ref e_ctsu_mode.

/** Forward declared CTSU Control block */
typedef void ctsu_ctrl_t;

/** Structure defining SFRs which unique to a CTSU mode. */
typedef struct st_ctsu_const_sfrs
{
    union
    {
        unsigned char byte;
    } ctsucr0;      ///< Control Register 0
    union
    {
        unsigned char byte;
    } ctsucr1;      ///< Control Register 1
    union
    {
        unsigned char byte;
    } ctsusdprs;    ///< Synchronous Noise Reduction Setting Register
    union
    {
        unsigned char byte;
    } ctsusst;      ///< Sensor Stabilization Wait Control Register
    union
    {
        unsigned char byte;
    } ctsuchac0;    ///< Channel Enable Control Register 0
    union
    {
        unsigned char byte;
    } ctsuchac1;    ///< Channel Enable Control Register 1
    union
    {
        unsigned char byte;
    } ctsuchac2;    ///< Channel Enable Control Register 2
    union
    {
        unsigned char byte;
    } ctsuchac3;    ///< Channel Enable Control Register 3
    union
    {
        unsigned char byte;
    } ctsuchac4;    ///< Channel Enable Control Register 4
    union
    {
        unsigned char byte;
    } ctsuchtrc0;   ///< Channel Transmit/Receive Control Register 0
    union
    {
        unsigned char byte;
    } ctsuchtrc1;   ///< Channel Transmit/Receive Control Register 1
    union
    {
        unsigned char byte;
    } ctsuchtrc2;   ///< Channel Transmit/Receive Control Register 2
    union
    {
        unsigned char byte;
    } ctsuchtrc3;   ///< Channel Transmit/Receive Control Register 3
    union
    {
        unsigned char byte;
    } ctsuchtrc4;   ///< Channel Transmit/Receive Control Register 4
    union
    {
        unsigned char byte;
    } ctsudclkc;    ///< High-Pass Noise Reduction Control Register
} ctsu_const_sfrs_t;                            ///< Refer: @ref st_ctsu_const_sfrs

/** Structure to be holding values to be written to the SFRs in the WR ISR*/
typedef struct st_ctsu_sensor_setting
{
    volatile uint16_t ctsussc;    ///< High-Pass Noise Reduction Spectrum Diffusion Control
    volatile uint16_t ctsuso0;    ///< Sensor Offset Register 0
    volatile uint16_t ctsuso1;    ///< Sensor Offset Register 1
} ctsu_sensor_setting_t;          ///< Refer: @ref st_ctsu_sensor_setting

/** Structure passed as argument to the function reading results @ref R_CTSU_Read. */
typedef struct st_ctsu_read_result
{
    void * p_dest;           ///< Pointer to user buffer where a copy of the result should be created.
    size_t size; ///< Size of the user buffer provided. @ref R_CTSU_Read will verify if sufficient size is available before writing.
    ctsu_read_cmd_t ctsu_result;        ///< The result user wants to read.
    uint16_t count;              ///< Number of valid indexes in @ref st_ctsu_read_result::sensor_offset.
    uint16_t * sensor_offset;    ///< Offset of sensor.
} ctsu_read_t;                          ///< Refer: @ref st_ctsu_read_result.

/** Structure passed to the control function */
typedef struct st_ctsu_control_arg
{
    ctsu_cmd_t cmd;         ///< Type of control command to execute
    void* p_context;        ///< Extended arguments passed into the control command
} ctsu_control_arg_t;       ///< Refer: @ref st_ctsu_control_arg.

/** Structure passed to the control function as extension to context. */
typedef struct st_ctsu_control_arg_ext
{
    uint16_t offset;      ///< Offset of sensor where the @ref st_ctsu_control_arg_ext::value should be placed.
    uint16_t value;       ///< Value of special function register.
} ctsu_control_arg_ext_t; ///< Refer: @ref st_ctsu_control_arg_ext @note Used when @ref st_ctsu_control_arg::cmd is either @ref CTSU_CMD_SET_CTSUSSC, @ref CTSU_CMD_SET_CTSUSO0, or @ref CTSU_CMD_SET_CTSUSO1

/** Structure defining what information gets passed as arguments to the user notification function @ref st_ctsu_cfg::p_callback.*/
typedef struct st_ctsu_callback_arg
{
    ctsu_ctrl_t const * handle_num;  ///< Handle identifier which generated this event.
    uint32_t event_mask;  ///< Event code mask. (Refer @ref ctsu_event_t)
    uint32_t info;        ///< Error code. (Refer @ref ctsu_err_t).
} ctsu_callback_arg_t;    ///< Refer: @ref st_ctsu_callback_arg.

/** Structure of a callback going to an upper layer. */
typedef void (*ctsu_callback_t)(ctsu_callback_arg_t const * const p_arg);

/** Structure defining a configuration to be passed to the Open function. */
typedef struct st_ctsu_cfg
{
    ctsu_const_sfrs_t * p_ctsu_settings;            ///< User defined SFR settings.
    ctsu_sensor_setting_t * p_sensor_settings;      ///< User defined settings for each active sensor.
    uint16_t * p_sensor_data;                       ///< Memory buffer location where CTSU measurement data is output. @note User must ensure this buffer has sufficient size.
    uint32_t pclkb_hz;                              ///< Frequency of the PCLKB for which configuration is valid.
    ctsu_callback_t p_callback;                     ///< Pointer to callback function to be used for event notifications.
    uint16_t const * const p_correction_ideal_sensor_ico;   ///< CTSU correction factor for primary sensor count readings measured from MCU used for calibration.
    uint16_t * const p_correction_buffer;                   ///< CTSU correction factor for secondary sensor count readings measured from MCU used for calibration.
    uint8_t const tscal_pin;                                ///< Pin used for calculation of CTSU correction factor.
} ctsu_cfg_t;                                         ///< Refer: @ref st_ctsu_cfg.

/*********************************************************************************************************************
 Application Programming Interface (Global Functions)
 *********************************************************************************************************************/

/** CTSU HAL driver API structure. Functions implemented at the HAL layer will follow this API. */
typedef struct st_ctsu_api
{
    /** Initialize the CTSU; enable power and clock and set the register configuration.
     * @par Implemented as
     *  - R_CTSU_Open()
     *
     * @param[in]  p_ctrl   Pointer to control handle structure
     * @param[in]  p_cfg    Pointer to configuration structure
     */
    ctsu_err_t (* open)(ctsu_ctrl_t * const p_ctrl, ctsu_cfg_t const * const p_cfg);

    /** Close the CTSU by ending any scan in progress, disabling interrupts, and removing power to the peripheral and
     * saving configurations according to options.
     * @par Implemented as
     *  - R_CTSU_Close()
     *
     * @param[in]  p_ctrl   Pointer to control handle structure
     */
    ctsu_err_t (* close)(ctsu_ctrl_t * const p_ctrl);

    /** Start off a single CTSU scan.
     * @par Implemented as
     *  - R_CTSU_Start_Scan()
     *
     * @param[in]  p_ctrl   Pointer to control handle structure
     */
    ctsu_err_t (* scan)(ctsu_ctrl_t * const p_ctrl);

    /** Read the results from the CTSU including raw data, binary data and other derived data according to the
     * selected options.
     * @par Implemented as
     *  - R_CTSU_Read()
     *
     * @param[in]  p_ctrl   Pointer to control handle structure
     * @param[in] p_arg    Pointer to the instance specifying the read command.
     */
    ctsu_err_t (* read)(ctsu_ctrl_t *  p_ctrl, ctsu_read_t * p_arg);

    /**Calibrate the CTSU handle. I.e. Bring sensor count ~~ reference counts.
     * @par Implemented as
     *  - R_CTSU_Update_Parameters()
     *
     * @param[in]  p_ctrl   Pointer to control handle structure
     */
    ctsu_err_t (* calibrate)(ctsu_ctrl_t * const p_ctrl);

    /** Change operating parameters in the specified control handle structure.
     * @par Implemented as
     *  - R_CTSU_Control()
     *
     * @param[in]  p_ctrl   Pointer to control handle structure
     * @param[in] p_arg     Pointer to the command specify control operation details.
     */
    ctsu_err_t (* control)(ctsu_ctrl_t * const p_ctrl, ctsu_control_arg_t* p_arg);

    /** Retrieve the API version.
     * @par Implemented as
     *  - R_CTSU_VersionGet()
     *
     * @pre This function retrieves the API version.
     * @param[in]  p_version   Pointer to version structure
     */
    ssp_err_t (* versionGet)(ssp_version_t * const p_version);
}ctsu_api_t;

/** This structure encompasses everything that is needed to use an instance of this interface. */
typedef struct st_ctsu_instance
{
    ctsu_ctrl_t         * p_ctrl; ///< Pointer to the control structure for this instance
    ctsu_cfg_t    const * p_cfg;  ///< Pointer to the configuration structure for this instance
    ctsu_api_t    const * p_api;  ///< Pointer to the API structure for this instance
} ctsu_instance_t;

#endif /* R_CTSU_API_H_ */
/*******************************************************************************************************************//**
 * @} (end defgroup R_CTSU)
 ***********************************************************************************************************************/
